/*
  This class has been generated by the Code Generator
*/

package com.worksitewsapppackage;

import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

import org.json.JSONArray;
import org.json.JSONObject;
import org.json.JSONTokener;

import com.cordys.cpc.bsf.busobject.BusObject;
import com.cordys.cpc.bsf.busobject.BusObjectConfig;
import com.cordys.cpc.bsf.busobject.QueryObject;
import com.eibus.util.logger.CordysLogger;
import com.eibus.xml.nom.Node;
import com.eibus.xml.xpath.XPath;


public class WKS_APP_REF_MAPPING extends WKS_APP_REF_MAPPINGBase
{
	public static CordysLogger logger=CordysLogger.getCordysLogger(WKS_APP_REF_MAPPING.class);
    public WKS_APP_REF_MAPPING()
    {
        this((BusObjectConfig)null);
    }

    public WKS_APP_REF_MAPPING(BusObjectConfig config)
    {
        super(config);
    }

    public static int updateDataToSalesforce(int requestXML)
    {
    	int responseNode=-1,errorNode=-1,masterAppNode=-1;
    	String patchResonse="",reqURL="",reqBody="",masterAppId="",accountId="",contactId="",response="",masterAppNo="",commissionId="";
    	String errorXML="<Error></Error>";
    	boolean errorFlag=true;
    			int counter=0; 
    	try
    	{
    		// validate the request xml
    		if(!Node.isValidNode(requestXML))
    		{
    			throw new Exception("The reqeust xml is not in proper XML format");
    		}
    		responseNode=WorksiteUtil.document.parseString("<root></root>");
    		masterAppNo=Node.getDataWithDefault(XPath.getFirstMatch(".//*[local-name()='KeyMasterApp']", null, requestXML), "");
    		BusObject caseObject=WKSOpsCase.getWksOpsCaseObjectByMasterAppNo(masterAppNo);
    		if(caseObject==null)
    		{
    			throw new Exception("The case is not availabel in WIMS");
    		}
    		//appId="a0D7A000002NWOvUAO";
    		masterAppId=caseObject.getStringProperty("MasterAppNo");
    		masterAppNode=WorksiteUtil.getMasterAppObjectById(masterAppId);
    		commissionId=Node.getDataWithDefault(XPath.getFirstMatch(".//*[local-name()='CommissionData']/.//*[local-name()='Id']", null, masterAppNode), "");    		//appId="a0D7A000002NWOvUAO";
    		JSONObject masterAppObject=new JSONObject();
    		JSONObject accountObject=new JSONObject();
    		JSONObject contactObject=new JSONObject();
    		JSONObject commissionObject=new JSONObject();
    		Map<String,JSONObject> dataObjects=new HashMap();
    		// refresh the access token
    		response=WorksiteUtil.getSecurityToken("refresh");
			JSONObject tokenObj=new JSONObject(response);
			if(WorksiteUtil.hasKey(tokenObj,"error"))
			{
				String errorText=tokenObj.getString("error")+":"+tokenObj.getString("error_description");
				throw new Exception("Access token is not refreshed, Error- "+errorText);
			}    		
    		// read master app data from the wksopscase
    		responseNode=WorksiteUtil.document.parseString("<root></root>");
    		// read the fields from the input xml
    		
    		// Get the field details from the table
    		int fieldsNode=XPath.getFirstMatch(".//*[local-name()='Fields']", null, requestXML);
    		if(Node.isValidNode(fieldsNode)) 
    		{
    			int fields[]=XPath.getMatchingNodes(".//*[local-name()='Field']", null, requestXML);
    			if(fields.length < 1)
    			{
    				throw new Exception("Fields are not available to update in request");
    			}

        		for(int i=0;i<fields.length;i++)
        		{
        			String wimsField=Node.getDataWithDefault(XPath.getFirstMatch(".//*[local-name()='Name']", null, fields[i]), "");
        			String fieldValue=Node.getDataWithDefault(XPath.getFirstMatch(".//*[local-name()='Value']", null, fields[i]), "");
        			fieldValue=(fieldValue==null)?"":fieldValue;
                               fieldValue=fieldValue.replaceAll("XMLampersand","&");
                               
               fieldValue =fieldValue.replaceAll("XMLdoublequotes","\"");
               fieldValue=fieldValue.replaceAll("XMLapos","\'");
               fieldValue=fieldValue.replaceAll("XMLgt",">");
               fieldValue =fieldValue.replaceAll("XMLlt","<");
//counter++;
        			try 
        			{

        				WKS_APP_REF_MAPPING wimsFieldObj=getFieldDetailsByName(wimsField);
        				if(wimsFieldObj!=null)
	        			{
        					DateFormat curFormater=null,targetFormater=null;
        					Date dateObj=null;
        					Calendar calendar=null;
        					DecimalFormat decimalFormat =null;
	        				String fieldName=wimsFieldObj.getField();
	        				String fieldType=wimsFieldObj.getFieldDataType();
	        				int fieldMaxLength=wimsFieldObj.getFieldMaxlength();
	        				String mandatoryFlag=wimsFieldObj.getMandatory();
	        				String appSubType=wimsFieldObj.getAppSubType();
	        				String apiUrl=wimsFieldObj.getApplicationURI();
	        				appSubType=(appSubType==null)?"":appSubType.toUpperCase();
	        				// validate the field
	        				
	        				if(mandatoryFlag.equalsIgnoreCase("Y"))
	        				{
	        					if(fieldValue==null || fieldValue.equalsIgnoreCase("") || fieldValue.isEmpty())
	        					{
	        						throw new Exception("The field is mandatory");
	        					}
	        				}
	        					        				
	        				// Format the the data
	        				
	        				switch (fieldType) {
	        				case "BOOLEAN":
	        					fieldValue=(fieldValue==null)?"":fieldValue;
	        					if(fieldValue.equalsIgnoreCase("Y") || fieldValue.equalsIgnoreCase("Yes") || fieldValue.equalsIgnoreCase("true"))
	        					{
	        						fieldValue="true";
	        					}
	        					else if(fieldValue.equalsIgnoreCase("N") || fieldValue.equalsIgnoreCase("No") || fieldValue.equalsIgnoreCase("false"))
	        					{
	        						fieldValue="false";
	        					}
	        					else
	        					{
	        						//throw new Exception("The field allowed values are Y,Yes,No,N,True,False");
	        						fieldValue="";
	        					}
	        					
	        					break;
	        				case "PHONE":
	        					fieldValue=(fieldValue==null)?"":fieldValue;
	        					//fieldValue = fieldValue.replaceAll("[^\\d.)(]", "");
	        					String phoneRegex ="[0-9*#+() -]*";
	        					if(!Pattern.matches(phoneRegex,fieldValue))
	        					{
	        						throw new Exception("Phone number is not valid");
	        					}
	        					if(fieldValue.length()>=10)
									fieldValue = fieldValue.substring(0, 10);
	        					break;
	        				case "EMAIL":
	        					if(fieldValue.length()>fieldMaxLength)
		        				{
		        					throw new Exception("The maximum length should be "+fieldMaxLength);
		        				}
	        					String emailRegex = "[_a-zA-Z1-9]+(\\.[A-Za-z0-9]*)*@[A-Za-z0-9]+\\.[A-Za-z0-9]+(\\.[A-Za-z0-9]*)*";
	        					if(!Pattern.matches(emailRegex,fieldValue))
	        					{
	        						throw new Exception("Email Address is not valid");
	        					}
	        					break;
	        				case "DOUBLE" :
	        					decimalFormat = new DecimalFormat(".0");
	        					try
	        					{
	        						fieldValue=decimalFormat.format(Double.parseDouble(fieldValue));
	        					}catch(Exception e)
	        					{
	        						fieldValue="0.0";
	        					}
								break;
	        				case "CURRENCY" :
	        					decimalFormat = new DecimalFormat(".0");
	        					try
	        					{
	        						fieldValue=decimalFormat.format(Double.parseDouble(fieldValue));
	        					}catch(Exception e)
	        					{
	        						fieldValue="0.0";
	        					}
	        					break;
	        				case "PERCENT" :
	        					decimalFormat = new DecimalFormat(".0");
	        					try
	        					{
	        						fieldValue=decimalFormat.format(Double.parseDouble(fieldValue));
	        					}catch(Exception e)
	        					{
	        						fieldValue="0.0";
	        					}
								break;

							case "DATE": 
								//curFormater = new SimpleDateFormat("MM/dd/yyyy");
								
									curFormater = new SimpleDateFormat("yyyy-MM-dd");
									targetFormater = new SimpleDateFormat("yyyy-MM-dd");
									try
									{
										dateObj = curFormater.parse(fieldValue);
									}catch(Exception e)
									{
										throw new Exception("The field should be date in yyyy-MM-dd");
									}
									calendar = Calendar.getInstance();
									calendar.setTime(dateObj);								
									fieldValue=targetFormater.format(calendar.getTime());
								
								
								break;
							case "DATETIME":
								
									curFormater = new SimpleDateFormat("yyyy-MM-dd");
									targetFormater = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS");
									try
									{
										dateObj = curFormater.parse(fieldValue);
									}catch(Exception e)
									{
										throw new Exception("The field should be date in yyyy-MM-dd");
									}
									calendar = Calendar.getInstance();
									calendar.setTime(dateObj);								
									fieldValue=targetFormater.format(calendar.getTime());
									
								
								break;

							default:
								//jsonObject.put(fieldName, fieldValue);
								if(fieldValue.length()>fieldMaxLength)
		        				{
		        					throw new Exception("The maximum length should be "+fieldMaxLength);
		        				}
								break;
							}
	        				switch (appSubType) 
	        				{
								case "MASTER_APPLICATION__C":
									if(!WorksiteUtil.hasKey(masterAppObject, fieldName))
									{
										apiUrl=apiUrl+"/"+masterAppId;
										masterAppObject.put(fieldName, fieldValue);
										dataObjects.put(apiUrl, masterAppObject);
									}									
									break;
								case "ACCOUNT":
									if(!WorksiteUtil.hasKey(accountObject, fieldName))
									{
										apiUrl=apiUrl+"/"+accountId;
										accountObject.put(fieldName, fieldValue);
										dataObjects.put(apiUrl, accountObject);
									}									
									break;
								case "CONTACT":
									if(!WorksiteUtil.hasKey(contactObject, fieldName))
									{
										apiUrl=apiUrl+"/"+contactId;
										contactObject.put(fieldName, fieldValue);
										dataObjects.put(apiUrl, contactObject);
									}									
									break;
								case "COMMISSION_DATA__C":
									if(!commissionId.equalsIgnoreCase("") && !commissionId.isEmpty())
									{
										apiUrl=apiUrl+"/"+commissionId;
										commissionObject.put(fieldName, fieldValue);
										dataObjects.put(apiUrl, commissionObject);
									}
									break;
								default:
									break;
							}
	        				
	        				
	        				errorFlag=false;
	        				// add to json object
	        			}
        				else
        				{
        					throw new Exception("The reference not found in mapping");
        				}
	        			
	        			
        			}catch(Exception e)
        			{
        				// prepare the error message for fields
        				errorFlag=true;
        				errorNode=WorksiteUtil.document.parseString(errorXML);
        				WorksiteUtil.document.createTextElement("FieldName", wimsField, errorNode);
        				WorksiteUtil.document.createTextElement("FieldError", e.getMessage(), errorNode);
        				Node.appendToChildren(errorNode, responseNode);
        			}
        		}
    		}
    		
    		// validate the data
    		
    		// post data to salesforce
    		if(!errorFlag && !Node.isValidNode(errorNode))
    		{	
        		//jsonObject.put("Client_Description_Comments__c", "This is comment from OT");
        		//jsonObject.put("Enrollment_Start_Date__c","2020-08-29");
String result="";
    			for ( Map.Entry<String, JSONObject> entry : dataObjects.entrySet()) {
    				//counter++;
    			    reqURL = entry.getKey();
    			    JSONObject jsonObject = entry.getValue();
    			    reqBody=jsonObject.toString();
            		patchResonse=WorksiteUtil.patchDataByURL(reqURL, true, reqBody);
            		//return success message
            		if(patchResonse!=null && patchResonse.equalsIgnoreCase("SUCCESS"))
            		{
            			//WorksiteUtil.document.createTextElement("PostRespose", patchResonse, responseNode);
            			result=patchResonse;
            			counter=counter+jsonObject.length();
            		}
            		else
            		{
            			JSONTokener tokener=new JSONTokener(patchResonse);
            			JSONArray array=(JSONArray)tokener.nextValue();
            			JSONObject errorObject=array.getJSONObject(0);
            			if(WorksiteUtil.hasKey(errorObject, "errorCode"))
            			{
            				String errorMsg=errorObject.get("message").toString();
            				throw new Exception("Error in sending request :"+errorMsg);
            			}
            		}
    			}
    			WorksiteUtil.document.createTextElement("PatchStatus", result, responseNode);
    			WorksiteUtil.document.createTextElement("NumberOfFields", Integer.toString(counter), responseNode);
        	
    		}    		
    	}catch(Exception ex)
    	{
    		WorksiteUtil.document.createTextElement("ErrorMessage", ex.getMessage(), responseNode);
    		logger.error("Error in updateDataToSalesforce method:"+ex);
    	}
    	finally
    	{
    		if(Node.isValidNode(masterAppNode)) 
    		{
    			Node.delete(masterAppNode);
    		}
    	}
    	return responseNode;
    }

	private static WKS_APP_REF_MAPPING getFieldDetailsByName(String fieldName) {
		String queryText = "select * from WKS_APP_REF_MAPPING where wimslabel = :fieldName";
        QueryObject query = new QueryObject(queryText);
        query.addParameter("fieldName", "WKS_APP_REF_MAPPING.wimslabel", QueryObject.PARAM_STRING, fieldName);
        query.setResultClass(WKS_APP_REF_MAPPING.class);
        return (WKS_APP_REF_MAPPING)query.getObject();
	}
}
